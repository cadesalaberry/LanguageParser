# COMP 250 Assignment 2

Instructor: Prof. Michael Langer
Posted: Tues, Oct. 9, 2012

### General Instructions

The same instructions apply as in Assignment 1.

## Question 1 (50 points) Due: Sun, Oct. 21, 2012 at 23:59

### Introduction

In this question, you will use a stack to implement a parser for a simple programming- like language. Much like the Java compiler tells you if there are syntactic errors in your code, your parser will check whether a given statement's syntax is correct or not with respect to the rules of this simple language.

One can define the syntax of a language using substitution rules. For example, a substitution rule like this:

	**digit** → 0|1|2|3|4|5|6|7|8|9
	
means that whenever the term **digit** occurs in a rule, it can be replaced by the character '0', or the character '1', or '2', and so on.

Rules can be recursive: for example, using the digit rule, we can define a recursive rule to describe what a non-negative integer should be:

	**integer** → **digit** | **digit integer**
	
This means that an **integer** is a single **digit** (base case), or a single **digit** preceding an
**integer** (recursive case).
We can define a variable in a similarly recursive way, namely as a sequence of letter characters.

	**letter** → a | b | ::: | z | A | B | ::: | Z
	
	**variable** → **letter** | **letter variable**

We next use integer’s and variable’s to define possible statement’s in a simple programming-like language, which is generated by the following substitution rules:

	**assignment** → **variable**=**integer**
	
	**bool** → true | false

	**statement** → **assignment** | if **bool** then **statement** else **statement** end
	
When you look at the starter code, you will see that there are two levels of parsing that are done. The first level splits the input string into “tokens”. There are a few points to note. First, the mechanism for parsing into tokens uses “regular expressions” rather than the recursive definition above. There is no significance to this, however. We used regular expressions to split tokens just because it is easier to do so in Java. Second, the splits are defined by the space characters. In particular, we require each **assignment** to be a single token. We do so by not allowing an **assignment** to contain any space characters. For example, “foo=23” is a valid **assignment** whereas “foo = 23” which contains spaces is not a valid **assignment**. The splitter which generates the sequence of tokens from the input string would treat “foo = 23” (with spaces) as three
separate tokens rather than as one assignment token.

**[updated Oct. 10]** Note that the keywords if, then, else, end, true, false are special tokens in the language. Usually in a programming language, such tokens cannot be used as variables -- even though these keywords are strings that satisfy the definition of a variable. In our language, however, a variable is always placed directly next to a “=” sign, i.e. no space characters. Our token parser allows for keywords to be used as variables, for example, “if=3” is indeed a valid assignment according to the token parser (see **isAssignment()** method in **LanguageTester**).

For any valid **statement** in the language, one **assignment** would be executed. For the case of an if-then-else statement, the one that is executed depends on the **bool** conditions. However, deciding which **assignment** is executed is not your task here. Rather, your task is to decide whether a given input string is a valid statement or not, according to the above rules.
For example, here are some examples of valid **statements**:

	* “foo=23” (with no spaces, see above)
	* “statement=23”
	* “if=3”
	* “if true then a=2 else b=31 end”
	* “if false then if true then c=5 else d=5 end else b=31 end”

and here are some examples of invalid statement’s:

	* “foo = 23” (with spaces)
	* “foo”
	* “foo=bar”
	* “false”
	* “if true then a=2 else b=31"
	* if a=2 then a=2 else b=31 end”
	* “if true a=2 else b=31 end”

In the starter code, an input string is parsed into a sequence of tokens. Your task is to write a token parser that processes these tokens in order. The parser returns true if the input string defines a valid **statement**, and false otherwise. There are four Java classes given in the starter code:
	
	* **StringSplitter:** This class implements a “lexical analyzer”, namely a **StringSplitter**       object that reads a string and splits it into tokens. It is fully implemented for you.

	* **StringStack:** Implementation of the Stack ADT for non-empty strings. It is fully implemented for you.

	* **LanguageParser:** A partial implementation of the (token) parser. You need to implement the **parse()** method in this class.

	* **Tester:** Used to test the correctness of your **parse()** method. The class has examples of how to use the **StringSplitter** class. Your **LanguageParser** class will be tested with a more extensive set of examples than what is given to you here.
	
 As in Assignment 1, we strongly encourage you to write your own tester classes and
share with the other students.


## Your task

Implement the **parse()** method of **LanguageParser**. You are not allowed to use recursion. Instead you must use a **StringStack**. You may use only one **StringStack** object, and your method must only do one pass over the tokens, i.e. each token will be read from the **StringSplitter** object exactly once. To make the task simpler, you are allowed to push any non-empty strings you want on the stack. i.e. You are not limited to pushing only tokens from the language.

While you are not allowed to submit a solution that uses recursion, the concepts of recursion are still important in this assignment. One approach to solving the problem is to first implement a recursive solution (without a stack), and convert the recursive solution into one that does use a stack.

Submit the class **LanguageParser()** to the A2 Q1 dropbox.

### For your interest:

The simple language defined above is an example of what is called a context-free grammar. The subject is very important in computer science. You will study it formally in COMP 330.
Also, the provided code uses Java regular expressions in a few places. Java regular expressions are based on formal regular expressions which you will also learn about in COMP 330. Regular expressions are commonly used in solving problems which involves text processing and you are encouraged to learn about them.






Tap into [The Echo Nest's](http://the.echonest.com/) Musical Brain for the best music search, information, recommendations and remix tools on the web.

Pyechonest is an open source Python library for the Echo Nest API.  With Pyechonest you have Python access to the entire set of API methods including:

  * **artist** - search for artists by name, description, or attribute, and get back detailed information about any artist including audio, similar artists, blogs, familiarity, hotttnesss, news, reviews, urls and video.
  * **song** - search songs by artist, title, description, or attribute (tempo, duration, etc) and get detailed information back about each song, such as hotttnesss, audio_summary, or tracks.
  * **track** - upload a track to the Echo Nest and receive summary information about the track including key, duration, mode, tempo, time signature along with detailed track info including timbre, pitch, rhythm and loudness information.

## Install
There are a few different ways you can install pyechonest:

* Use setuptools: "easy_install -U pyechonest"
* Download the zipfile from the [downloads](https://github.com/echonest/pyechonest/archives/master) page and install it. 
* Checkout the source: "git clone git://github.com/echonest/pyechonest.git" and install it yourself.
   
## Getting Started
 * Install Pyechonest
 * **Get an API key** - to use the Echo Nest API you need an Echo Nest API key.  You can get one for free at [developer.echonest.com](http://developer.echonest.com).
 * **Set the API** key - you can do this one of two ways:
  * set an environment variable named ECHO_NEST_API_KEY to your API key
  * Include this snippet of code at the beginning of your python scripts:
    from pyechonest import config
    config.ECHO_NEST_API_KEY="YOUR API KEY"
 * Check out the [docs](http://echonest.github.com/pyechonest/) and examples below.

## Examples
*All examples assume you have already setup your api key!*

Find artists that are similar to 'Bikini Kill':

    from pyechonest import artist
    bk = artist.Artist('bikini kill')
    print "Artists similar to: %s:" % (bk.name,)
    for similar_artist in bk.similar:
        print "\t%s" % (similar_artist.name,)

Search for artist:

    from pyechonest import artist
    weezer_results = artist.search(name='weezer')
    weezer = weezer_results[0]
    weezer_blogs = weezer.blogs
    print 'Blogs about weezer:', [blog.get('url') for blog in weezer_blogs]

Get an artist by name:

    from pyechonest import artist
    a = artist.Artist('lady gaga')
    print a.id

Get an artist by Musicbrainz ID:

    from pyechonest import artist
    a = artist.Artist('musicbrainz:artist:a74b1b7f-71a5-4011-9441-d0b5e4122711')
    print a.name

Get the top hottt artists:

    from pyechonest import artist
    for hottt_artist in artist.top_hottt():
        print hottt_artist.name, hottt_artist.hotttnesss

Search for songs:

    from pyechonest import song
    rkp_results = song.search(artist='radiohead', title='karma police')
    karma_police = rkp_results[0]
    print karma_police.artist_location
    print 'tempo:',karma_police.audio_summary['tempo'],'duration:',karma_police.audio_summary['duration']

Get a song's audio_url and analysis_url:

    from pyechonest import song
    ss_results = song.search(artist='the national', title='slow show', buckets=['id:7digital', 'tracks'], limit=True)
    slow_show = ss_results[0]
    ss_tracks = slow_show.get_tracks('7digital')
    print ss_tracks[0].get('preview_url')

![alt text](http://i.imgur.com/WWLYo.gif "Frustrated cat can't believe this is the 12th time he's clicked on an auto-linked README.md URL")
